<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curator</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href="manifest.json">
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Montserrat:wght@600;700;800&display=swap"
        rel="stylesheet">
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Styles -->
    <link rel="stylesheet" href="styles.css">
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
</head>

<body>
    <div id="root"></div>

    <!-- Main App Logic Inlined for local file:// support -->
    <script type="text/babel">
        const { useState, useEffect } = React;

        // --- Icons ---
        const PlusIcon = () => <i className="ph ph-plus" style={{ fontSize: 20 }} />;
        const ImageIcon = () => <i className="ph ph-image" style={{ fontSize: 20 }} />;
        const LinkIcon = () => <i className="ph ph-link" style={{ fontSize: 20 }} />;
        const XIcon = () => <i className="ph ph-x" style={{ fontSize: 20 }} />;
        const DotsIcon = () => <i className="ph ph-dots-three-vertical" style={{ fontSize: 20 }} />;
        const ListIcon = () => <i className="ph ph-list" style={{ fontSize: 20 }} />;
        const TrashIcon = () => <i className="ph ph-trash" style={{ fontSize: 20 }} />;
        const MagicIcon = () => <i className="ph ph-magic-wand" style={{ fontSize: 20 }} />;
        const ShareIcon = () => <i className="ph ph-share-network" style={{ fontSize: 20 }} />;
        const SettingsIcon = () => <i className="ph ph-gear" style={{ fontSize: 20 }} />;
        const CheckIcon = () => <i className="ph ph-check" style={{ fontSize: 20 }} />;
        const SpinnerIcon = () => <i className="ph ph-spinner" style={{ fontSize: 20, animation: 'spin 1s linear infinite' }} />;

        // --- Category Icons ---
        const MusicNoteIcon = () => <i className="ph ph-music-note" />;
        const BookIcon = () => <i className="ph ph-book" />;
        const FilmStripIcon = () => <i className="ph ph-film-strip" />;
        const GameControllerIcon = () => <i className="ph ph-game-controller" />;
        const ForkKnifeIcon = () => <i className="ph ph-fork-knife" />;
        const MapPinIcon = () => <i className="ph ph-map-pin" />;
        const CategoryIcon = ({ category }) => {
            const cat = category ? category.toLowerCase() : 'general';
            if (cat.includes('music')) return <MusicNoteIcon />;
            if (cat.includes('book')) return <BookIcon />;
            if (cat.includes('movie') || cat.includes('film')) return <FilmStripIcon />;
            if (cat.includes('game')) return <GameControllerIcon />;
            if (cat.includes('food') || cat.includes('eat')) return <ForkKnifeIcon />;
            if (cat.includes('place') || cat.includes('travel') || cat.includes('trip')) return <MapPinIcon />;
            return <ListIcon />;
        };

        // --- Brand Logo ---
        const CuratorLogo = () => (
            <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" style={{ width: '100%', height: '100%' }}>
                <defs>
                    <linearGradient id="brand_grad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stopColor="#c084fc" /> {/* Lighter Violet */}
                        <stop offset="50%" stopColor="#3b82f6" /> {/* Blue */}
                        <stop offset="100%" stopColor="#db2777" /> {/* Deep Pink */}
                    </linearGradient>
                    <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
                        <feDropShadow dx="0" dy="4" stdDeviation="4" floodColor="#000" floodOpacity="0.3" />
                        <feDropShadow dx="0" dy="2" stdDeviation="2" floodColor="#3b82f6" floodOpacity="0.2" />
                    </filter>
                </defs>
                <g filter="url(#glow)">
                    {/* Stack of rounded bars forming a 'C' - Adjusted widths for smoother curve */}
                    <rect x="25" y="15" width="55" height="10" rx="5" fill="url(#brand_grad)" />
                    <rect x="15" y="29" width="45" height="10" rx="5" fill="url(#brand_grad)" />
                    <rect x="10" y="43" width="45" height="10" rx="5" fill="url(#brand_grad)" />
                    <rect x="15" y="57" width="50" height="10" rx="5" fill="url(#brand_grad)" />
                    <rect x="25" y="71" width="55" height="10" rx="5" fill="url(#brand_grad)" />
                </g>
            </svg>
        );

        // --- Components ---

        function App() {
            // --- Global State ---
            // --- Global State ---
            const [lists, setLists] = useState(() => {
                try {
                    const saved = localStorage.getItem('universal_app_lists');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            return parsed;
                        }
                    }
                    // Migration from old single-list version if exists
                    const oldItems = localStorage.getItem('universal_list_items');
                    if (oldItems) {
                        return [{ id: 'default', title: 'My List', icon: 'list', items: JSON.parse(oldItems) }];
                    }
                    return [{ id: 'default', title: 'My First List', icon: 'list', items: [] }];
                } catch (e) {
                    console.error("Failed to load lists", e);
                    return [{ id: 'default', title: 'My First List', icon: 'list', items: [] }];
                }
            });



            const [activeListId, setActiveListId] = useState(null);

            // --- UI State ---
            const [inputMode, setInputMode] = useState('simple');
            const [isEditingTitle, setIsEditingTitle] = useState(false); // Replaces showSettings
            const [simpleText, setSimpleText] = useState('');
            const [richData, setRichData] = useState({ title: '', image: '', year: '', creator: '', subtitle: '' });
            const [searchResults, setSearchResults] = useState([]);
            const [isSearching, setIsSearching] = useState(false);

            // Bulk Import State
            const [isImporting, setIsImporting] = useState(false);
            const [importText, setImportText] = useState('');

            // Bulk Delete State
            const [isSelectionMode, setIsSelectionMode] = useState(false);
            const [selectedItemIds, setSelectedItemIds] = useState(new Set());

            // Search Modal State
            const [searchModalItem, setSearchModalItem] = useState(null);
            const [searchModalQuery, setSearchModalQuery] = useState('');

            // Persistence
            useEffect(() => {
                localStorage.setItem('universal_app_lists', JSON.stringify(lists));
            }, [lists]);

            // Helper to get active list
            const activeList = activeListId ? lists.find(l => l.id === activeListId) : null;

            // Reset selection when switching lists
            useEffect(() => {
                setIsSelectionMode(false);
                setSelectedItemIds(new Set());
            }, [activeListId]);

            const handleToggleSelection = (id) => {
                const newSelected = new Set(selectedItemIds);
                if (newSelected.has(id)) {
                    newSelected.delete(id);
                } else {
                    newSelected.add(id);
                }
                setSelectedItemIds(newSelected);
            };

            const handleDeleteSelected = () => {
                if (selectedItemIds.size === 0) return;

                if (confirm(`Delete ${selectedItemIds.size} items?`)) {
                    setLists(lists.map(list =>
                        list.id === activeListId
                            ? { ...list, items: list.items.filter(item => !selectedItemIds.has(item.id)) }
                            : list
                    ));
                    setIsSelectionMode(false);
                    setSelectedItemIds(new Set());
                }
            };

            // ... (extractMetadata and detectCategory remain unchanged) ...

            const handleBulkImport = () => {
                if (!importText.trim()) return;

                const lines = importText.split(/\n/);
                const newItems = lines
                    .map(line => line.trim())
                    .filter(line => line.length > 0)
                    .map((line, index) => ({
                        id: Date.now() + index,
                        content: line,
                        completed: false,
                        image: null,
                        year: null,
                        creator: null,
                        link: null,
                        metadataFetched: false // Optional: could auto-fetch later
                    }));

                if (newItems.length > 0) {
                    setLists(lists.map(list =>
                        list.id === activeListId
                            ? { ...list, items: [...list.items, ...newItems] }
                            : list
                    ));
                    setImportText('');
                    setIsImporting(false);
                }
            };

            // ... (existing functions) ...

            const renderImportModal = () => (
                <div className="modal-overlay" onClick={() => setIsImporting(false)}>
                    <div className="modal-content glass-panel" onClick={e => e.stopPropagation()}>
                        <div className="modal-header">
                            <h3>Bulk Import Items</h3>
                            <button className="icon-btn" onClick={() => setIsImporting(false)}><XIcon /></button>
                        </div>
                        <div className="modal-body">
                            <p>Paste a list of items (one per line) from your spreadsheet or notes:</p>
                            <textarea
                                className="import-textarea"
                                value={importText}
                                onChange={e => setImportText(e.target.value)}
                                placeholder="Paste items here..."
                                rows={10}
                                autoFocus
                            />
                        </div>
                        <div className="modal-actions">
                            <button className="btn-secondary" onClick={() => setIsImporting(false)}>Cancel</button>
                            <button className="btn-primary" onClick={handleBulkImport}>
                                Import {importText.split(/\n/).filter(l => l.trim()).length > 0 ? `${importText.split(/\n/).filter(l => l.trim()).length} Items` : ''}
                            </button>
                        </div>
                    </div>
                </div>
            );

            // Render Search Modal
            const renderSearchModal = () => (
                <div className="modal-overlay" onClick={() => setSearchModalItem(null)}>
                    <div className="modal-content glass-panel" style={{ maxWidth: '400px' }} onClick={e => e.stopPropagation()}>
                        <div className="modal-header">
                            <h3>Search Comics.org</h3>
                            <button className="icon-btn" onClick={() => setSearchModalItem(null)}><XIcon /></button>
                        </div>
                        <div className="modal-body">
                            <p>Refine your search (e.g. add Issue #):</p>
                            <input
                                type="text"
                                className="main-input-transparent"
                                style={{ border: '1px solid rgba(255,255,255,0.2)', padding: '10px', borderRadius: '8px', background: 'rgba(0,0,0,0.2)' }}
                                value={searchModalQuery}
                                onChange={e => setSearchModalQuery(e.target.value)}
                                onKeyDown={e => {
                                    if (e.key === 'Enter') {
                                        window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(searchModalQuery + ' comics.org cover')}`, '_blank');
                                        setSearchModalItem(null);
                                    }
                                }}
                                autoFocus
                            />
                        </div>
                        <div className="modal-actions" style={{ flexDirection: 'column', gap: '8px', alignItems: 'stretch' }}>
                            <button className="btn-primary" onClick={() => {
                                window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(searchModalQuery + ' "comics.org" cover')}`, '_blank');
                                setSearchModalItem(null);
                            }}>
                                Google Images (Comics.org) <i className="ph ph-google-logo" style={{ marginLeft: 6 }} />
                            </button>
                            <button className="btn-secondary" onClick={() => {
                                // Search for Series on GCD
                                window.open(`https://www.comics.org/search/advanced/process/?target=sequence&method=icontains&logic=False&keywords=${encodeURIComponent(searchModalQuery)}`, '_blank');
                                setSearchModalItem(null);
                            }}>
                                GCD Series Search <i className="ph ph-magnifying-glass" style={{ marginLeft: 6 }} />
                            </button>
                            <button className="btn-secondary" onClick={() => {
                                window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(searchModalQuery + ' cover')}`, '_blank');
                                setSearchModalItem(null);
                            }}>
                                Google Images (Any) <i className="ph ph-image" style={{ marginLeft: 6 }} />
                            </button>
                            <button className="btn-secondary" onClick={() => setSearchModalItem(null)}>Cancel</button>
                        </div>
                    </div>
                </div>
            );



            const extractMetadata = (text) => {
                let year = '';
                let creator = '';

                // Extract Year (4 digits starting with 19 or 20)
                const yearMatch = text.match(/\b(19|20)\d{2}\b/);
                if (yearMatch) year = yearMatch[0];

                // Extract Creator based on common patterns
                const directorMatch = text.match(/directed by ([A-Z][a-z]+ [A-Z][a-z]+)/);
                if (directorMatch) creator = directorMatch[1];

                if (!creator) {
                    const authorMatch = text.match(/(?:written|novel|book) by ([A-Z][a-z]+ [A-Z][a-z]+)/);
                    if (authorMatch) creator = authorMatch[1];
                }

                if (!creator) {
                    const artistMatch = text.match(/album by ([A-Z][a-z]+ [A-Z][a-z]+)/);
                    if (artistMatch) creator = artistMatch[1];
                }

                return { year, creator };
            };

            // --- Auto-Category Detection ---
            const detectCategory = (title) => {
                const t = title.toLowerCase();
                if (t.match(/movie|film|watch|cinema/)) return 'movie';
                if (t.match(/book|read|novel|literature/)) return 'book';
                if (t.match(/music|song|listen|album/)) return 'music';
                if (t.match(/game|play|arcade/)) return 'game';
                if (t.match(/food|eat|grocery|restaurant|diet|cook/)) return 'food';
                if (t.match(/place|visit|travel|trip|journey/)) return 'place';
                return 'general';
            };

            const handleTitleSave = (newTitle) => {
                if (newTitle.trim()) {
                    const newCategory = detectCategory(newTitle);
                    setLists(lists.map(list =>
                        list.id === activeListId ? { ...list, title: newTitle, category: newCategory } : list
                    ));
                    setIsEditingTitle(false);
                }
            };

            // Fix/Migrate Categories for existing lists
            useEffect(() => {
                let hasChanges = false;
                const updatedLists = lists.map(list => {
                    const detected = detectCategory(list.title);
                    if (detected !== 'general' && list.category === 'general') {
                        hasChanges = true;
                        return { ...list, category: detected };
                    }
                    return list;
                });
                if (hasChanges) {
                    setLists(updatedLists);
                }
            }, []); // Run once on mount to fix bad categories from old saves

            const getCategoryActionLabel = (category) => {
                switch (category) {
                    case 'movie': return 'Watched';
                    case 'book': return 'Read';
                    case 'music': return 'Listened';
                    case 'game': return 'Played';
                    case 'food': return 'Ate';
                    case 'place': return 'Visited';
                    default: return 'Done';
                }
            };

            const actionLabel = activeList ? getCategoryActionLabel(activeList.category || 'general') : '';

            // --- Validators ---
            const updateActiveList = (newItems) => {
                setLists(lists.map(l => l.id === activeListId ? { ...l, items: newItems } : l));
            };

            const handleAddList = () => {
                const name = prompt("Name of new list?");
                if (name) {
                    const category = detectCategory(name);
                    const newList = { id: Date.now().toString(), title: name, category, icon: 'list', items: [] };
                    setLists([...lists, newList]);
                    setActiveListId(newList.id);
                }
            };

            const handleDeleteList = (e, listId) => {
                e.stopPropagation(); // Prevent navigation
                if (confirm("Are you sure you want to delete this list? This cannot be undone.")) {
                    setLists(lists.filter(l => l.id !== listId));
                    if (activeListId === listId) setActiveListId(null); // Go to home if deleted active
                }
            };

            // --- Item Logic ---

            const handleAddItem = () => {
                // If items are selected from search, add those instead of the input text
                if (selectedResultIds.size > 0) {
                    handleAddSelected();
                    return;
                }

                let newItem;
                if (inputMode === 'simple') {
                    if (!simpleText.trim()) return;
                    newItem = {
                        id: Date.now(),
                        type: 'text',
                        content: simpleText,
                        completed: false,
                        createdAt: new Date().toISOString()
                    };
                    setSimpleText('');
                } else {
                    if (!richData.title.trim()) return;
                    newItem = {
                        id: Date.now(),
                        type: 'rich',
                        content: richData.title,
                        completed: false,
                        metadata: { ...richData },
                        createdAt: new Date().toISOString()
                    };
                    setRichData({ title: '', image: '', year: '', creator: '', subtitle: '' });
                    setInputMode('simple');
                }
                updateActiveList([newItem, ...activeList.items]);
            };


            // --- Magic Fill ---


            // --- Features ---
            const handleDeleteItem = (itemId) => {
                if (confirm("Are you sure you want to delete this item?")) {
                    updateActiveList(activeList.items.filter(i => i.id !== itemId));
                }
            };

            const handleToggleComplete = (itemId) => {
                const updatedItems = activeList.items.map(i =>
                    i.id === itemId ? { ...i, completed: !i.completed } : i
                );
                updateActiveList(updatedItems);
            };

            const [selectedResultIds, setSelectedResultIds] = useState(new Set());

            const handleToggleOwned = (e, itemId) => {
                e.stopPropagation();
                const updatedItems = activeList.items.map(i => {
                    if (i.id === itemId) {
                        const currentMeta = i.metadata || {};
                        return { ...i, metadata: { ...currentMeta, owned: !currentMeta.owned } };
                    }
                    return i;
                });
                updateActiveList(updatedItems);
            };

            const handleSelectResult = (result) => {
                const newSelection = new Set(selectedResultIds);
                if (newSelection.has(result.id)) {
                    newSelection.delete(result.id);
                } else {
                    newSelection.add(result.id);
                }
                setSelectedResultIds(newSelection);

                // Optional: Preview functionality if needed, or just let them select.
                // For now, we DO NOT close the search results.
            };

            const handleAddSelected = () => {
                const selectedItems = searchResults.filter(r => selectedResultIds.has(r.id));
                const newItems = selectedItems.map((item, index) => ({
                    id: Date.now() + index,
                    type: 'rich',
                    content: item.title,
                    completed: false,
                    metadata: {
                        image: item.image,
                        year: item.year,
                        creator: item.creator,
                        subtitle: '',
                        owned: false
                    },
                    createdAt: new Date().toISOString()
                }));

                updateActiveList([...newItems, ...activeList.items]);
                setSearchResults([]);
                setSelectedResultIds(new Set());
                setInputMode('simple');
                setRichData({ title: '', image: '', year: '', creator: '', subtitle: '' });
            };

            // --- Item Magic Wand Logic ---
            const fetchWikipediaSummary = async (query) => {
                try {
                    const res = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`);
                    if (!res.ok) return null;
                    return await res.json();
                } catch (e) {
                    return null;
                }
            };

            const handleItemMagic = async (item) => {
                if (item.completed) return; // Don't magic completed items

                // Show loading state (optimistic update separate from metadata to avoid flicker?)
                // For simplicity, we just do it.

                const query = item.content;
                const cat = activeList.category;
                let meta = { ...item.metadata };
                let found = false;

                // 1. Try Google Books if book
                if (cat === 'book' || cat === 'books') {
                    try {
                        const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=1`);
                        const data = await res.json();
                        if (data.items && data.items[0]) {
                            const info = data.items[0].volumeInfo;
                            meta.image = info.imageLinks ? (info.imageLinks.thumbnail || info.imageLinks.smallThumbnail).replace('http:', 'https:') : meta.image;
                            meta.year = info.publishedDate ? info.publishedDate.substring(0, 4) : meta.year;
                            meta.creator = info.authors ? info.authors[0] : meta.creator;
                            found = true;
                        }
                    } catch (e) { console.error(e); }
                }

                // 2. Try iTunes if music
                if (!found && (cat === 'music')) {
                    try {
                        const res = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&media=music&entity=album&limit=1`);
                        const data = await res.json();
                        if (data.results && data.results[0]) {
                            const alb = data.results[0];
                            meta.image = alb.artworkUrl100 ? alb.artworkUrl100.replace('100x100', '600x600') : meta.image;
                            meta.year = alb.releaseDate ? alb.releaseDate.substring(0, 4) : meta.year;
                            meta.creator = alb.artistName || meta.creator;
                            found = true;
                        }
                    } catch (e) { console.error(e); }
                }

                // 3. Fallback: Wikipedia (Great for "Football Picture Story Monthly" etc)
                if (!found || !meta.image) {
                    const wikiData = await fetchWikipediaSummary(query);
                    if (wikiData) {
                        if (wikiData.thumbnail && wikiData.thumbnail.source) {
                            meta.image = wikiData.thumbnail.source;
                            found = true;
                        }
                        if (wikiData.description) {
                            // Maybe store description? For now just image is the prize.
                        }
                        if (wikiData.extract) {
                            // Extract year/creator from text? Hard.
                        }
                    }
                }

                if (found) {
                    updateActiveList(activeList.items.map(i => i.id === item.id ? { ...i, type: 'rich', metadata: meta } : i));
                } else {
                    if (confirm(`Couldn't auto-find "${query}". Search manually?`)) {
                        setSearchModalItem(item);
                        setSearchModalQuery(item.content);
                    }
                }
            };

            const handleMagicFill = async () => {
                const query = richData.title;
                if (!query) { alert("Type a title first!"); return; }

                setRichData({ ...richData, subtitle: 'Searching...' });

                try {
                    // --- MOVIE SEARCH (Wikipedia Filmographies) ---
                    if (activeList.category === 'movie' || activeList.category === 'movies' || activeList.category === 'film') {
                        // 1. Resolve Page Title (e.g. "Christopher Nolan" -> "Christopher Nolan filmography")
                        let pageTitle = query;
                        const searchRes = await fetch(`https://en.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(query + ' filmography')}&limit=1&format=json&origin=*`);
                        const searchData = await searchRes.json();

                        // If "Christopher Nolan filmography" exists, use it. Otherwise fallback to just name.
                        if (searchData[1] && searchData[1].length > 0) {
                            pageTitle = searchData[1][0];
                        } else {
                            // Fallback: Try just the name
                            const nameRes = await fetch(`https://en.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(query)}&limit=1&format=json&origin=*`);
                            const nameData = await nameRes.json();
                            if (nameData[1] && nameData[1].length > 0) pageTitle = nameData[1][0];
                        }

                        // 2. Fetch Page HTML
                        const parseRes = await fetch(`https://en.wikipedia.org/w/api.php?action=parse&page=${encodeURIComponent(pageTitle)}&prop=text&format=json&origin=*`);
                        const parseData = await parseRes.json();

                        if (!parseData.parse || !parseData.parse.text) {
                            alert("Couldn't find filmography info on Wikipedia.");
                            setRichData(prev => ({ ...prev, subtitle: '' }));
                            return;
                        }

                        const htmlContent = parseData.parse.text['*'];
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlContent, 'text/html');

                        // 3. Extract Films from Wikitables
                        const tables = doc.querySelectorAll('.wikitable');
                        const films = [];
                        const seenTitles = new Set();

                        // Global check: Does ANY table on this page look like a Director table?
                        let pageHasDirectorTable = false;
                        tables.forEach(table => {
                            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                            if (headers.some(h => h.includes('director') || h.includes('directed'))) pageHasDirectorTable = true;
                        });

                        tables.forEach(table => {
                            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
                            const titleIndex = headers.findIndex(h => h.includes('title') || h.includes('film'));
                            const yearIndex = headers.findIndex(h => h.includes('year'));
                            const directorIndex = headers.findIndex(h => h.includes('director') || h.includes('directed'));
                            const roleIndex = headers.findIndex(h => h.includes('role'));

                            if (titleIndex === -1 && yearIndex === -1) return; // Not a useful table

                            // Valid Filter: If this IS a Director page, SKIP tables without Director columns.
                            // This filters out "Documentary appearances" etc.
                            if (pageHasDirectorTable && directorIndex === -1) return;

                            // Filter out "Shorts" table if explicitly labeled or is a navbox
                            if (table.classList.contains('navbox') || table.classList.contains('vertical-navbox') || table.classList.contains('nowraplinks')) return;

                            const tableCaption = table.querySelector('caption');
                            if (tableCaption && tableCaption.textContent.toLowerCase().includes('short')) return;
                            // Check headers for "Shorts" (Navbox usually puts it in th)
                            if (headers.some(h => h.match(/shorts?/i))) return;

                            const rows = table.querySelectorAll('tr');
                            rows.forEach(row => {
                                const cells = row.querySelectorAll('td');
                                if (cells.length === 0) return;

                                // Global Short Film Filter per Row
                                const rowText = row.textContent.toLowerCase();
                                if (rowText.includes('short film') || rowText.includes('documentary short')) return;

                                // Filter for Director if column exists
                                if (directorIndex !== -1) {
                                    // Adjust for row headers (th) which might shift index?
                                    // Wikitables often have <th scope="row">Year</th> at start.
                                    // The headers array was from ALL th's. 
                                    // Row cells are tds. 
                                    // If headers include the Year column (often index 0), then cells index matches.
                                    // Handle rowspans: If row has fewer cells than headers, assume first col (Year) is spanned.
                                    // Effective index shifts left by (headers.length - row.children.length).
                                    // Usually headers.length is e.g. 6, row.length is 5 -> shift 1.
                                    const offset = headers.length - row.children.length;
                                    const effectiveIndex = directorIndex - offset;

                                    if (effectiveIndex >= 0 && effectiveIndex < row.children.length) {
                                        const dirCell = row.children[effectiveIndex];
                                        if (dirCell) {
                                            const text = dirCell.textContent.trim().toLowerCase();
                                            const isYes = text.includes('yes') || text.includes('âœ“') || dirCell.querySelector('img[alt*="Yes"]') || dirCell.classList.contains('table-yes') || text.includes('director') || text.includes('directed');

                                            // If strict director column exists (like Nolan's), it must be Yes.
                                            if (!isYes) return;
                                        }
                                    }
                                } else if (roleIndex !== -1) {
                                    // Filter for Role column
                                    const roleCell = row.children[roleIndex];
                                    if (roleCell && !roleCell.textContent.toLowerCase().includes('director')) return;
                                }

                                let title = '';
                                let searchTitle = '';
                                let year = '';

                                // Extract Title
                                const titleCell = row.children[titleIndex];
                                if (titleCell) {
                                    // Prefer link text, else italic text, else full text
                                    const link = titleCell.querySelector('a');
                                    const italic = titleCell.querySelector('i');
                                    title = link ? link.textContent : (italic ? italic.textContent : titleCell.innerText);
                                    // Cleanup quotes, etc.
                                    title = title.replace(/^"/, '').replace(/"$/, '').trim();

                                    if (link) {
                                        const href = link.getAttribute('href');
                                        if (href && href.startsWith('/wiki/')) {
                                            searchTitle = decodeURIComponent(href.replace('/wiki/', '')).replace(/_/g, ' ');
                                        }
                                    }
                                    if (!searchTitle) searchTitle = title;
                                }

                                // Extract Year
                                const yearCell = row.children[yearIndex];
                                if (yearCell) {
                                    year = yearCell.textContent.trim().substring(0, 4);
                                }
                                if (title && title.length > 2 && !seenTitles.has(title)) {
                                    if (title.match(/variable|season|episode|unknown/i)) return;

                                    films.push({
                                        id: title + year,
                                        title: title,
                                        searchTitle: searchTitle,
                                        year: year,
                                        creator: query,
                                        image: '',
                                        subtitle: year ? `(${year})` : ''
                                    });
                                    seenTitles.add(title);
                                }
                            });
                        });

                        // 4. Batch Fetch Images (REST API Summary)
                        if (films.length > 0) {
                            setRichData(prev => ({ ...prev, subtitle: `Found ${films.length} films. Fetching images...` }));
                            const titles = films.slice(0, 50); // Limit to 50

                            // Process in parallel with concurrency limit
                            const chunkSize = 5;
                            for (let i = 0; i < titles.length; i += chunkSize) {
                                const chunk = titles.slice(i, i + chunkSize);
                                await Promise.all(chunk.map(async (film) => {
                                    try {
                                        // Use searchTitle which handles redirects/formatting best
                                        const titleToFetch = film.searchTitle || film.title;
                                        const res = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(titleToFetch)}`);
                                        if (res.ok) {
                                            const data = await res.json();
                                            if (data.thumbnail && data.thumbnail.source) {
                                                film.image = data.thumbnail.source;
                                            } else if (data.originalimage && data.originalimage.source) {
                                                film.image = data.originalimage.source;
                                            }
                                        }
                                    } catch (e) { /* ignore */ }
                                }));
                            }
                        }

                        // Sort by Year (descending)
                        films.sort((a, b) => (b.year || '0') - (a.year || '0'));

                        if (films.length > 0) {
                            setSearchResults(films);
                            setRichData(prev => ({ ...prev, subtitle: `Found ${films.length} films for ${pageTitle}` }));
                        } else {
                            alert(`Found the page "${pageTitle}" but couldn't parse any films.`);
                            setRichData(prev => ({ ...prev, subtitle: '' }));
                        }
                        return;
                    }

                    // --- BOOK SEARCH (Google Books API) ---
                    if (activeList.category === 'book') {
                        const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=20`);
                        const data = await response.json();

                        if (data.items && data.items.length > 0) {
                            const results = data.items.map(item => {
                                const info = item.volumeInfo;
                                return {
                                    id: item.id,
                                    title: info.title,
                                    year: info.publishedDate ? info.publishedDate.substring(0, 4) : '',
                                    creator: info.authors ? info.authors[0] : '',
                                    image: info.imageLinks ? (info.imageLinks.thumbnail || info.imageLinks.smallThumbnail).replace('http:', 'https:') : '',
                                    subtitle: info.description ? (info.description.length > 100 ? info.description.substring(0, 100) + '...' : info.description) : ''
                                };
                            });
                            setSearchResults(results);
                            setRichData(prev => ({ ...prev, subtitle: 'Select a match...' }));
                        } else {
                            alert("No book found on Google Books.");
                            setRichData(prev => ({ ...prev, subtitle: '' }));
                        }
                        return;
                    }

                    // --- MUSIC SEARCH (iTunes API - Dual Strategy) ---
                    if (activeList.category === 'music') {
                        const keywordPromise = fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&media=music&entity=album&limit=50`)
                            .then(res => res.json())
                            .then(data => data.results || []);

                        const artistPromise = fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&media=music&entity=musicArtist&limit=1`)
                            .then(res => res.json())
                            .then(async data => {
                                if (data.results && data.results.length > 0) {
                                    const artistId = data.results[0].artistId;
                                    const albumsRes = await fetch(`https://itunes.apple.com/lookup?id=${artistId}&entity=album&limit=200`);
                                    const albumsData = await albumsRes.json();
                                    return (albumsData.results || []).filter(item => item.collectionType === 'Album');
                                }
                                return [];
                            })
                            .catch(() => []); // If artist logic fails, ignore

                        const [keywordResults, artistResults] = await Promise.all([keywordPromise, artistPromise]);
                        const allRawResults = [...artistResults, ...keywordResults];

                        if (allRawResults.length > 0) {
                            // Deduplicate by collectionId
                            const seenIds = new Set();
                            const results = [];

                            // Process: Prefer Artist results first? Or just mix?
                            // Sorting by date will handle order.
                            for (const item of allRawResults) {
                                if (!item.collectionId) continue;
                                if (seenIds.has(item.collectionId)) continue;
                                seenIds.add(item.collectionId);

                                results.push({
                                    id: String(item.collectionId),
                                    title: item.collectionName,
                                    year: item.releaseDate ? item.releaseDate.substring(0, 4) : '',
                                    fullDate: item.releaseDate || '',
                                    creator: item.artistName,
                                    image: item.artworkUrl100 ? item.artworkUrl100.replace('100x100', '600x600') : '',
                                    subtitle: item.copyright || ''
                                });
                            }

                            // Sort Chronologically (Newest First) as requested/implied standard
                            results.sort((a, b) => {
                                if (a.fullDate < b.fullDate) return 1;
                                if (a.fullDate > b.fullDate) return -1;
                                return 0;
                            });

                            setSearchResults(results);
                            setRichData(prev => ({ ...prev, subtitle: 'Select matches...' }));
                        } else {
                            alert("No music found on iTunes.");
                            setRichData(prev => ({ ...prev, subtitle: '' }));
                        }
                        return;
                    }

                    // --- UNIVERSAL SEARCH (Wikipedia) ---
                    // Context-aware search based on list category
                    let searchSuffix = '';
                    switch (activeList.category) {
                        case 'music': searchSuffix = ' music band album'; break;
                        case 'movie': searchSuffix = ' film movie'; break;
                        case 'game': searchSuffix = ' video game'; break;
                        case 'food': searchSuffix = ' food dish'; break;
                        case 'place': searchSuffix = ' location'; break;
                    }
                    const fullQuery = query + searchSuffix;

                    // Wikipedia API
                    const endpoint = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&prop=pageimages|extracts|pageprops&generator=search&gsrnamespace=0&gsrlimit=5&gsrsearch=${encodeURIComponent(fullQuery)}&pithumbsize=500&exintro&explaintext&exsentences=2`;

                    const response = await fetch(endpoint);
                    const data = await response.json();

                    if (data.query && data.query.pages) {
                        const pages = Object.values(data.query.pages).sort((a, b) => a.index - b.index);

                        const results = pages.map(page => {
                            let imageUrl = page.thumbnail ? page.thumbnail.source : '';
                            const { year, creator } = extractMetadata(page.extract || '');
                            return {
                                id: page.pageid,
                                title: page.title,
                                image: imageUrl,
                                year,
                                creator,
                                subtitle: ''
                            };
                        });

                        setSearchResults(results);
                        setRichData(prev => ({ ...prev, subtitle: 'Select a match...' }));
                    } else {
                        alert("No matches found on Wikipedia.");
                        setRichData(prev => ({ ...prev, subtitle: '' }));
                    }
                } catch (error) {
                    console.error("Magic Fill Error:", error);
                    alert("Failed to fetch data.");
                    setRichData(prev => ({ ...prev, subtitle: '' }));
                }
            };

            const handleShare = () => {
                const text = `List: ${activeList.title}\n` + activeList.items.map(i => `- ${i.content} ${i.metadata?.subtitle ? '(' + i.metadata.subtitle + ')' : ''}`).join('\n');
                navigator.clipboard.writeText(text);
                alert("List copied to clipboard!");
            };

            return (
                <div className="app-shell">
                    {/* Sidebar */}
                    <nav className="sidebar glass-panel">
                        <div className="sidebar-header">
                            <div className="brand-wrapper" style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                <CuratorLogo />
                                <h2>Curator</h2>
                            </div>
                            <button className="icon-btn" onClick={handleAddList}><PlusIcon /></button>
                        </div>
                        <ul className="nav-lists">
                            <li
                                className={`nav-item ${activeListId === null ? 'active' : ''}`}
                                onClick={() => setActiveListId(null)}
                            >
                                <i className="ph ph-house" style={{ fontSize: 20 }} />
                                <span style={{ flex: 1 }}>Home</span>
                            </li>
                            {lists.map(list => (
                                <li
                                    key={list.id}
                                    className={`nav-item ${list.id === activeListId ? 'active' : ''}`}
                                    onClick={() => setActiveListId(list.id)}
                                >
                                    <ListIcon />
                                    <span style={{ flex: 1 }}>{list.title}</span>
                                    <button
                                        className="sidebar-delete-btn"
                                        onClick={(e) => handleDeleteList(e, list.id)}
                                        title="Delete List"
                                    >
                                        <i className="ph ph-trash" />
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </nav>

                    {/* Main Content */}
                    <main className="main-content">
                        {!activeList ? (
                            /* --- DASHBOARD VIEW --- */
                            <div className="dashboard-view">
                                <header className="dashboard-intro">
                                    <div className="dashboard-logo-large">
                                        <CuratorLogo />
                                    </div>
                                    <h1>Welcome to Curator</h1>
                                    <p>Organize your life's collections. Select a list or start something new.</p>
                                </header>
                                <div className="dashboard-grid">
                                    {lists.map(list => (
                                        <div
                                            key={list.id}
                                            className="dashboard-card"
                                            onClick={() => setActiveListId(list.id)}
                                        >
                                            <div className="card-preview">
                                                <CategoryIcon category={list.category} />
                                            </div>

                                            <div className="card-content-wrapper">
                                                <h3>{list.title}</h3>
                                                <div className="card-meta">{list.items.length} Items</div>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="dashboard-card new-list-card" onClick={handleAddList}>
                                        <div className="card-icon"><PlusIcon /></div>
                                        <h3>New Collection</h3>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            /* --- LIST VIEW --- */
                            <>
                                <header>
                                    {isEditingTitle ? (
                                        <input
                                            type="text"
                                            className="title-input"
                                            defaultValue={activeList.title}
                                            autoFocus
                                            onBlur={(e) => handleTitleSave(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && handleTitleSave(e.target.currentTarget.value)}
                                        />
                                    ) : (
                                        <h1 onDoubleClick={() => setIsEditingTitle(true)} title="Double-click to rename">
                                            {activeList.title}
                                        </h1>
                                    )}
                                    <div className="header-actions">
                                        {isSelectionMode ? (
                                            <>
                                                <button className="btn-secondary small" onClick={() => setIsSelectionMode(false)}>Cancel</button>
                                                <button className="btn-primary small danger" onClick={handleDeleteSelected} disabled={selectedItemIds.size === 0}>
                                                    Delete ({selectedItemIds.size})
                                                </button>
                                            </>
                                        ) : (
                                            <>
                                                <button className="icon-btn" onClick={() => setIsSelectionMode(true)} title="Select Items">
                                                    <CheckIcon />
                                                </button>
                                                <button className="icon-btn" onClick={() => setIsImporting(true)} title="Bulk Import">
                                                    <i className="ph ph-copy" style={{ fontSize: 20 }} />
                                                </button>
                                                <button className="icon-btn" onClick={handleShare} title="Share List">
                                                    <ShareIcon />
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </header>

                                <div className={`smart-input-container ${inputMode === 'rich' ? 'expanded' : ''}`}>
                                    {inputMode === 'simple' ? (
                                        <div className="input-wrapper glass-panel">
                                            <input
                                                type="text"
                                                className="main-input-transparent"
                                                placeholder="Add a new item..."
                                                value={simpleText}
                                                onChange={(e) => setSimpleText(e.target.value)}
                                                onKeyDown={(e) => e.key === 'Enter' && handleAddItem()}
                                                autoFocus
                                            />
                                            <div className="input-actions">
                                                <button className="action-btn" onClick={() => setInputMode('rich')}><ImageIcon /></button>
                                                <button className="action-btn primary" onClick={handleAddItem}><PlusIcon /></button>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="rich-input-wrapper glass-panel">
                                            <div className="rich-header">
                                                <span>New Rich Item</span>
                                                <button className="close-btn action-btn" onClick={() => setInputMode('simple')}><XIcon /></button>
                                            </div>
                                            <div className="rich-form">
                                                <div className="rich-row">
                                                    <input
                                                        type="text"
                                                        className="rich-field title-field"
                                                        placeholder="Title (e.g. Lord of the Rings)"
                                                        value={richData.title}
                                                        onChange={e => setRichData({ ...richData, title: e.target.value })}
                                                    />
                                                    <button className="magic-btn" onClick={handleMagicFill} title="Magic Fill Metadata" disabled={isSearching}>
                                                        {isSearching ? <SpinnerIcon /> : <MagicIcon />}
                                                    </button>
                                                </div>

                                                {/* Search Results Dropdown */}
                                                {searchResults.length > 0 && (
                                                    <div className="search-results glass-panel">
                                                        <div className="results-header" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                            <span>Select items to add:</span>
                                                            {selectedResultIds.size > 0 && (
                                                                <button className="add-rich-btn small" onClick={handleAddSelected}>
                                                                    Add {selectedResultIds.size} Selected
                                                                </button>
                                                            )}
                                                        </div>
                                                        {searchResults.map(result => (
                                                            <div
                                                                key={result.id}
                                                                className={`result-item ${selectedResultIds.has(result.id) ? 'selected' : ''}`}
                                                                onClick={() => handleSelectResult(result)}
                                                            >
                                                                <div className={`checkbox-circle ${selectedResultIds.has(result.id) ? 'checked' : ''}`}>
                                                                    {selectedResultIds.has(result.id) && <CheckIcon />}
                                                                </div>
                                                                {result.image ? (
                                                                    <img src={result.image} alt="cover" className="result-thumb" />
                                                                ) : <div className="result-thumb-placeholder"><ImageIcon /></div>}
                                                                <div className="result-info">
                                                                    <div className="result-title">{result.title}</div>
                                                                    <div className="result-meta">
                                                                        {result.year && <span>{result.year}</span>}
                                                                        {result.creator && <span>â€¢ {result.creator}</span>}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}

                                                <div className="rich-row">
                                                    <input
                                                        type="text"
                                                        className="rich-field"
                                                        placeholder="Image URL"
                                                        value={richData.image}
                                                        onChange={e => setRichData({ ...richData, image: e.target.value })}
                                                    />
                                                </div>
                                                <div className="rich-row">
                                                    <input
                                                        type="text"
                                                        className="rich-field"
                                                        placeholder="Year (e.g. 2024)"
                                                        value={richData.year}
                                                        style={{ width: '30%' }}
                                                        onChange={e => setRichData({ ...richData, year: e.target.value })}
                                                    />
                                                    <input
                                                        type="text"
                                                        className="rich-field"
                                                        placeholder="Creator (Director, Author...)"
                                                        value={richData.creator}
                                                        style={{ width: '70%' }}
                                                        onChange={e => setRichData({ ...richData, creator: e.target.value })}
                                                    />
                                                </div>
                                                <div className="rich-row">
                                                    <textarea
                                                        className="rich-field"
                                                        placeholder="Description / Plot Summary..."
                                                        value={richData.subtitle}
                                                        rows={3}
                                                        onChange={e => setRichData({ ...richData, subtitle: e.target.value })}
                                                    />
                                                </div>
                                                <button className="add-rich-btn" onClick={handleAddItem}>
                                                    {selectedResultIds.size > 0 ? `Add ${selectedResultIds.size} Selected Items` : 'Add Item'}
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                <div className="list-container">
                                    {activeList.items.length === 0 ? (
                                        <div className="empty-state"><p>Empty list.</p></div>
                                    ) : (
                                        activeList.items.map(item => (
                                            <div
                                                key={item.id}
                                                className={`list-item glass-panel ${item.completed ? 'completed' : ''} ${isSelectionMode ? 'selection-mode' : ''} ${selectedItemIds.has(item.id) ? 'selected' : ''}`}
                                                onClick={() => isSelectionMode ? handleToggleSelection(item.id) : null}
                                            >
                                                {isSelectionMode && (
                                                    <div className="selection-checkbox">
                                                        {selectedItemIds.has(item.id) ? <div className="checkbox-fill"><CheckIcon /></div> : <div className="checkbox-empty" />}
                                                    </div>
                                                )}

                                                {item.type === 'rich' ? (
                                                    <div className="item-content rich-grid">
                                                        {item.metadata.image ? (
                                                            <img src={item.metadata.image} alt={item.content} className="item-image" />
                                                        ) : <div className="item-image-placeholder"><ImageIcon /></div>}

                                                        <div className="item-text-wrapper">
                                                            <div className="item-title">{item.content}</div>
                                                        </div>

                                                        <div className="meta-col year">
                                                            {item.metadata.year ? <span className="meta-badge">{item.metadata.year}</span> : null}
                                                        </div>

                                                        <div className="meta-col creator">
                                                            {item.metadata.creator ? <span className="meta-creator">{item.metadata.creator}</span> : null}
                                                        </div>

                                                        <div className="meta-col owned">
                                                            {/* Moved to actions */}
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="item-content">
                                                        <div className="item-text-wrapper">
                                                            <div className="item-title">{item.content}</div>
                                                        </div>
                                                    </div>
                                                )}

                                                {!isSelectionMode && (
                                                    <div className="item-actions-right">
                                                        <div className="status-stack">
                                                            <button
                                                                className={`status-btn ${item.completed ? 'active' : ''}`}
                                                                onClick={() => handleToggleComplete(item.id)}
                                                            >
                                                                {item.completed && <CheckIcon />} <span>{actionLabel}</span>
                                                            </button>

                                                            {!item.completed && (
                                                                <>
                                                                    <button className="magic-item-btn" onClick={() => handleItemMagic(item)} title="Auto-find Image & Info">
                                                                        <MagicIcon />
                                                                    </button>
                                                                    <button className="icon-btn small" onClick={() => {
                                                                        const url = prompt("Paste Image URL:");
                                                                        if (url) {
                                                                            const updated = activeList.items.map(i => i.id === item.id ? { ...i, type: 'rich', metadata: { ...i.metadata, image: url } } : i);
                                                                            updateActiveList(updated);
                                                                        }
                                                                    }} title="Set Image URL Manualy">
                                                                        <LinkIcon />
                                                                    </button>
                                                                    <button className="icon-btn small" onClick={() => {
                                                                        setSearchModalItem(item);
                                                                        setSearchModalQuery(item.content);
                                                                    }} title="Search Comics.org with Issue #">
                                                                        <i className="ph ph-magnifying-glass" />
                                                                    </button>
                                                                </>
                                                            )}

                                                            {item.type === 'rich' && activeList.category !== 'movie' && (
                                                                <button
                                                                    className={`owned-btn ${item.metadata?.owned ? 'owned' : ''}`}
                                                                    onClick={(e) => handleToggleOwned(e, item.id)}
                                                                >
                                                                    <i className={item.metadata?.owned ? "ph-fill ph-check-circle" : "ph ph-circle"} />
                                                                    <span>Owned</span>
                                                                </button>
                                                            )}
                                                        </div>
                                                        <button className="delete-btn" onClick={() => handleDeleteItem(item.id)}><TrashIcon /></button>
                                                    </div>
                                                )}
                                            </div>
                                        ))
                                    )}
                                </div>
                            </>
                        )}
                    </main>
                    {isImporting && renderImportModal()}
                    {searchModalItem && renderSearchModal()}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>